/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import React, { useRef, useEffect, useMemo } from "react";
import { useGLTF, useAnimations } from "@react-three/drei";
import { useFrame } from "@react-three/fiber";
import { useStore } from "../store/store";
import * as THREE from "three";
import FrankAnim from "../data/Frank.gltf";
import { AnimationUtils, Clock } from "three";
export function Frank({ ...props }) {
	const group = useRef();
	const { nodes, materials, animations } = useGLTF(FrankAnim);
	const { actions, names, mixer } = useAnimations(animations, group);

	//Use Store
	const aI = useStore((state) => state.aI);
	let isPlaying = useStore((state) => state.isPlaying);
	let isPaused = useStore((state) => state.isPaused);
	const setAnimationsArray = useStore((state) => state.updateAnimationArray);
	const timescale = useStore((state) => state.timescale);
	const loop = useStore((state) => state.loop);
	const bounce = useStore((state) => state.bounce);
	const currentAnim = useStore((state) => state.currentAnim);
	const start = useStore((state) => state.start);
	const end = useStore((state) => state.end);
	const setClipDuration = useStore((state) => state.setClipDuration);
	const setCurrentTime = useStore((state) => state.setCurrentTime);
	const setSliderStart = useStore((state) => state.setSliderStart);
	const setSliderEnd = useStore((state) => state.setSliderEnd);
	const addToAnimationArray = useStore((state) => state.addToAnimationArray);
	useEffect(() => setSliderStart(start), [setSliderStart, start]);
	useEffect(() => setSliderEnd(end), [setSliderEnd, end]);

	//Solves Problem with infinte renders of Animations Array and successfully passes to store
	useMemo(
		() => Promise.resolve(names).then((results) => setAnimationsArray(results)),
		[names, setAnimationsArray]
	);

	// Handle Animation Loop
	//bounce
	useEffect(() => {
		bounce
			? actions[currentAnim].setLoop(THREE.LoopPingPong)
			: actions[currentAnim].setLoop(THREE.LoopRepeat);
	}, [bounce, aI, actions, names, mixer, currentAnim]);
	//loop
	useEffect(() => {
		loop
			? actions[currentAnim].setLoop(THREE.LoopRepeat)
			: actions[currentAnim].setLoop(THREE.LoopOnce);
	}, [loop, aI, actions, names, mixer, currentAnim]);
	//Timescale (SlowMo, FullSpeed, Timeslider) functionality
	useEffect(() => {
		actions[currentAnim].timeScale = timescale;
	}, [timescale, actions, mixer, currentAnim]);

	// Play Pause functionality
	useEffect(() => {
		isPaused
			? (actions[currentAnim].timeScale = 0)
			: (actions[currentAnim].timeScale = timescale);
	}, [timescale, isPaused, aI, actions, names, currentAnim]);

	// Get Clip Duration and set .startAt time
	useEffect(() => {
		const duration = actions[currentAnim].getClip().duration;
		const startHere = start * duration;

		isPlaying ? actions[currentAnim].play() : actions[currentAnim].play();
	}, [isPlaying, aI, actions, names, mixer, currentAnim, start]);
	useFrame(() => {
		//console.log(mixer.time);
		setCurrentTime(actions[currentAnim].time);
	});

	useEffect(() => {
		const currentClip = actions[currentAnim].getClip();
		const clipDuration = actions[currentAnim].getClip().duration;
		const clipFrameLength = currentClip.tracks[0].times.length;
		const startHere = start * clipFrameLength;
		const endHere = end * clipFrameLength;
		//console.log();

		const currentMixer = actions[currentAnim].getMixer();
		const newClip = AnimationUtils.subclip(
			currentClip,
			`${currentClip.name} Short`,
			startHere,
			endHere,
			240
		);
		currentMixer.clipAction(newClip, group);
		// console.log("existing action", currentMixer.existingAction(newClip));
		// console.log("currentClip", currentClip);
		console.log("newClip", newClip);
		console.log("group", group);
		console.log("mixer", currentMixer);
		console.log("currentClip", currentClip.duration);
		console.log("newClip", newClip.duration);
		console.log("startHere", startHere);
		console.log("endHere", endHere);
		console.log(
			"testNumber",
			((endHere - startHere) * clipDuration) / clipFrameLength
		);
		// return currentMixer.existingAction.stopAllAction();
	}, [start, end, currentAnim]);
	useEffect(() => {
		setCurrentTime(actions[currentAnim].time);
		setClipDuration(actions[currentAnim].getClip().duration);
	}, [currentAnim, actions]);
	//Resets Animations Player on Change of CurrentAnim
	useEffect(() => {
		mixer.stopAllAction();
		actions[currentAnim].play();
	}, [currentAnim]);
	useEffect(() => {
		const duration = actions[currentAnim].getClip().duration;
		const startHere = start * duration;
		//console.log("startHere", startHere);
		actions[currentAnim].startAt(startHere);
	}, [currentAnim, start]);

	return (
		<group ref={group} {...props} dispose={null}>
			<group rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
				<primitive object={nodes.mixamorig1Hips} />
				<skinnedMesh
					frustumCulled={false}
					geometry={nodes.Skin.geometry}
					material={materials.Ch36_Body}
					skeleton={nodes.Skin.skeleton}
				/>
			</group>
		</group>
	);
}

useGLTF.preload("/Frank.gltf");
